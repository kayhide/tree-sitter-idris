================================================================================
Interfaces 1
================================================================================

interface Show a where
    show : a -> String

--------------------------------------------------------------------------------

(idris
  (interface
    (interface_head
      (interface_name)
      (type_variable))
    (interface_body
      (where)
      (signature
        (loname)
        (type_name
          (loname))
        (arrow_separator)
        (type_name
          (caname))))))

================================================================================
Interfaces 2
================================================================================

Show Nat where
    show Z = "Z"

--------------------------------------------------------------------------------

(idris
  (implementation
    (implementation_head
      (interface_name)
      (type_name
        (caname)))
    (implementation_body
      (where)
      (function
        (lhs
          (funvar
            (loname)
            (patterns
              (pat_name
                (caname)))))
        (rhs
          (exp_literal
            (string)))))))

================================================================================
Default Definitions
================================================================================

interface Eq a where
    x /= y = not (x == y)

--------------------------------------------------------------------------------

(idris
  (interface
    (interface_head
      (interface_name)
      (type_variable))
    (interface_body
      (where)
      (function
        (lhs
          (funvar
            (loname)
            (patterns
              (pat_op)
              (pat_name
                (loname)))))
        (rhs
          (exp_name
            (loname))
          (exp_parens
            (exp_name
              (loname))
            (exp_op)
            (exp_name
              (loname))))))))

================================================================================
Extending Interfaces 1
================================================================================

interface Eq a => Ord a where
    compare : a -> a -> Ordering

--------------------------------------------------------------------------------

(idris
  (interface
    (interface_head
      (constraints
        (constraint
          (interface_name)
          (type_name
            (loname))))
      (interface_name)
      (type_variable))
    (interface_body
      (where)
      (signature
        (loname)
        (type_name
          (loname))
        (arrow_separator)
        (type_name
          (loname))
        (arrow_separator)
        (type_name
          (caname))))))

================================================================================
Extending Interfaces 2
================================================================================

interface (Ord a, Show a) => OrdShow a where

--------------------------------------------------------------------------------

(idris
  (interface
    (interface_head
      (constraints
        (constraint
          (interface_name)
          (type_name
            (loname)))
        (comma)
        (constraint
          (interface_name)
          (type_name
            (loname))))
      (interface_name)
      (type_variable))
    (interface_body
      (where))))

================================================================================
Quantities for Parameters 1
================================================================================

interface Functor (0 f : Type -> Type) where

--------------------------------------------------------------------------------

(idris
  (interface
    (interface_head
      (interface_name)
      (annotated_type_variable
        (quantity)
        (type_variable)
        (type_name
          (caname))
        (arrow_separator)
        (type_name
          (caname))))
    (interface_body
      (where))))

================================================================================
Quantities for Parameters 2
================================================================================

interface Functor f => Applicative (0 f : Type -> Type) where

--------------------------------------------------------------------------------

(idris
  (interface
    (interface_head
      (constraints
        (constraint
          (interface_name)
          (type_name
            (loname))))
      (interface_name)
      (annotated_type_variable
        (quantity)
        (type_variable)
        (type_name
          (caname))
        (arrow_separator)
        (type_name
          (caname))))
    (interface_body
      (where))))

================================================================================
Implimentation keyword
================================================================================

implementation Functor (SortedMap k) where

--------------------------------------------------------------------------------

(idris
  (implementation
    (implementation_head
      (interface_name)
      (type_parens
        (type_name
          (caname))
        (type_name
          (loname))))
    (implementation_body
      (where))))

================================================================================
Implimentation with qualified op in parens
================================================================================

{x : a} -> Injective (Vect.(::) x) where

--------------------------------------------------------------------------------

(idris
  (implementation
    (implementation_head
      (type_braces
        (implicit_arg
          (type_name
            (loname)))
        (type_name
          (loname)))
      (interface_name)
      (type_parens
        (type_name
          (qualified_operator
            (module)))
        (type_name
          (loname))))
    (implementation_body
      (where))))

================================================================================
Implimentation with empty list
================================================================================

Uninhabited (Data.Colist.InBounds k []) where

--------------------------------------------------------------------------------

(idris
  (implementation
    (implementation_head
      (interface_name)
      (type_parens
        (type_name
          (qualified_caname
            (module)
            (module)
            (caname)))
        (type_name
          (loname))
        (type_list)))
    (implementation_body
      (where))))

================================================================================
Implementation with implicit arguments
================================================================================

{0 xs : List a} -> 
Either (Uninhabited $ x === y) (Uninhabited $ xs === ys) => 
Uninhabited (x::xs = y::ys) where

--------------------------------------------------------------------------------

(idris
  (implementation
    (implementation_head
      (type_braces
        (implicit_arg
          (quantity)
          (type_name
            (loname)))
        (type_name
          (caname))
        (type_name
          (loname)))
      (interface_name)
      (type_parens
        (type_name
          (caname))
        (type_op)
        (type_name
          (loname))
        (type_op)
        (type_name
          (loname)))
      (type_parens
        (type_name
          (caname))
        (type_op)
        (type_name
          (loname))
        (type_op)
        (type_name
          (loname)))
      (arrow_separator)
      (type_name
        (caname))
      (type_parens
        (type_name
          (loname))
        (type_op)
        (type_name
          (loname))
        (type_op)
        (type_name
          (loname))
        (type_op)
        (type_name
          (loname))))
    (implementation_body
      (where))))

================================================================================
Implementation with implicit arguments inside constraints
================================================================================

({x : k} -> Semigroup (v x)) => Monoid (SortedDMap k v) where
  neutral = empty

--------------------------------------------------------------------------------

(idris
  (implementation
    (implementation_head
      (constraints
        (type_braces
          (implicit_arg
            (type_name
              (loname)))
          (type_name
            (loname)))
        (constraint
          (interface_name)
          (type_parens
            (type_name
              (loname))
            (type_name
              (loname)))))
      (interface_name)
      (type_parens
        (type_name
          (caname))
        (type_name
          (loname))
        (type_name
          (loname))))
    (implementation_body
      (where)
      (function
        (lhs
          (funvar
            (loname)))
        (rhs
          (exp_name
            (loname)))))))

================================================================================
Implementation with implicit arguments inside constraint tuples
================================================================================

(DecEq k, {x : k} -> Eq (v x)) => Eq (SortedDMap k v) where
  (==) = (==) `on` toList

--------------------------------------------------------------------------------

(idris
  (implementation
    (implementation_head
      (constraints
        (constraint
          (interface_name)
          (type_name
            (loname)))
        (comma)
        (type_braces
          (implicit_arg
            (type_name
              (loname)))
          (type_name
            (loname)))
        (constraint
          (interface_name)
          (type_parens
            (type_name
              (loname))
            (type_name
              (loname)))))
      (interface_name)
      (type_parens
        (type_name
          (caname))
        (type_name
          (loname))
        (type_name
          (loname))))
    (implementation_body
      (where)
      (function
        (lhs
          (funvar
            (operator)))
        (rhs
          (exp_name
            (operator))
          (exp_ticked
            (exp_name
              (loname)))
          (exp_name
            (loname)))))))

================================================================================
Implementation with qualified operator
================================================================================

Biinjective Prelude.(::) where

--------------------------------------------------------------------------------

(idris
  (implementation
    (implementation_head
      (interface_name)
      (type_name
        (qualified_operator
          (module))))
    (implementation_body
      (where))))

================================================================================
Named Implementations 1
================================================================================

[myord] Ord Nat where

--------------------------------------------------------------------------------

(idris
  (implementation
    (implementation_head
      (implementation_name
        (loname))
      (interface_name)
      (type_name
        (caname)))
    (implementation_body
      (where))))

================================================================================
Named Implementations 2
================================================================================

[PlusNatMonoid] Monoid Nat using PlusNatSemi where

--------------------------------------------------------------------------------

(idris
  (implementation
    (implementation_head
      (implementation_name
        (caname))
      (interface_name)
      (type_name
        (caname))
      (using
        (implementation_name
          (caname))))
    (implementation_body
      (where))))

================================================================================
Explicit arguments 1
================================================================================

_ = sort @{myord} xs

--------------------------------------------------------------------------------

(idris
  (function
    (lhs
      (wildcard))
    (rhs
      (exp_name
        (loname))
      (exp_explicit_impl
        (exp_name
          (loname)))
      (exp_name
        (loname)))))

================================================================================
Explicit arguments 2
================================================================================

and = force . concat @{All}

--------------------------------------------------------------------------------

(idris
  (function
    (lhs
      (funvar
        (loname)))
    (rhs
      (exp_name
        (loname))
      (exp_op)
      (exp_name
        (loname))
      (exp_explicit_impl
        (exp_name
          (caname))))))

================================================================================
Empty implementation
================================================================================

Num Foo

--------------------------------------------------------------------------------

(idris
  (implementation
    (implementation_head
      (interface_name)
      (type_name
        (caname)))))

================================================================================
Implementation with deeply nested exp
================================================================================

FiniteBits Bits16 where
  popCount x0 =
    let x1 = (x0 .&. 0x5555) + ((x0 `shiftR` 1) .&. 0x5555)
     in cast x1

--------------------------------------------------------------------------------

(idris
  (implementation
    (implementation_head
      (interface_name)
      (type_name
        (caname)))
    (implementation_body
      (where)
      (function
        (lhs
          (funvar
            (loname)
            (patterns
              (pat_name
                (loname)))))
        (rhs
          (exp_let_in
            (declarations
              (lhs
                (pat_name
                  (loname)))
              (rhs
                (exp_parens
                  (exp_name
                    (loname))
                  (exp_op)
                  (exp_literal
                    (integer)))
                (exp_op)
                (exp_parens
                  (exp_parens
                    (exp_name
                      (loname))
                    (exp_ticked
                      (exp_name
                        (loname)))
                    (exp_literal
                      (integer)))
                  (exp_op)
                  (exp_literal
                    (integer)))))
            (in
              (exp_name
                (loname))
              (exp_name
                (loname)))))))))

================================================================================
Implementation with visibility
================================================================================

export %inline
Cast Char Nat where

--------------------------------------------------------------------------------

(idris
  (implementation
    (implementation_head
      (visibility)
      (pragma_inline)
      (interface_name)
      (type_name
        (caname))
      (type_name
        (caname)))
    (implementation_body
      (where))))

================================================================================
Implementation with constriants
================================================================================

public export
[Reverse] (fwd : Ord a) => Ord a where

--------------------------------------------------------------------------------

(idris
  (implementation
    (implementation_head
      (visibility)
      (implementation_name
        (caname))
      (constraints
        (constraint
          (annotated_type_variable
            (type_variable)
            (type_name
              (caname))
            (type_name
              (loname)))))
      (interface_name)
      (type_name
        (loname)))
    (implementation_body
      (where))))

================================================================================
Implementation with more constriants
================================================================================

public export
[Compose] (l : Applicative f) => (r : Applicative g) => Applicative (f . g)
  using Functor.Compose where

--------------------------------------------------------------------------------

(idris
  (implementation
    (implementation_head
      (visibility)
      (implementation_name
        (caname))
      (constraints
        (constraint
          (annotated_type_variable
            (type_variable)
            (type_name
              (caname))
            (type_name
              (loname)))))
      (constraints
        (constraint
          (annotated_type_variable
            (type_variable)
            (type_name
              (caname))
            (type_name
              (loname)))))
      (interface_name)
      (type_parens
        (type_name
          (loname))
        (type_op)
        (type_name
          (loname)))
      (using
        (implementation_name
          (module)
          (caname))))
    (implementation_body
      (where))))

================================================================================
Interface Constructors
================================================================================

interface A t => B t where
  constructor MkB

--------------------------------------------------------------------------------

(idris
  (interface
    (interface_head
      (constraints
        (constraint
          (interface_name)
          (type_name
            (loname))))
      (interface_name)
      (type_variable))
    (interface_body
      (where)
      (caname))))

================================================================================
Determining Parameters
================================================================================

interface Monad m => MonadState s (0 m : Type -> Type) | m where

--------------------------------------------------------------------------------

(idris
  (interface
    (interface_head
      (constraints
        (constraint
          (interface_name)
          (type_name
            (loname))))
      (interface_name)
      (type_variable)
      (annotated_type_variable
        (quantity)
        (type_variable)
        (type_name
          (caname))
        (arrow_separator)
        (type_name
          (caname)))
      (determining_params
        (loname)))
    (interface_body
      (where))))
